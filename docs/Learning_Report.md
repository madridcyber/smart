# Learning_Report.md - گزارش یادگیری

این فایل بازتابی از یادگیری‌های فنی در طول توسعه پروژه پلتفرم مدیریت هوشمند دانشگاه است.

> **توجه:** این فایل خلاصه‌ای از گزارش کامل `ai-interaction-report.md` است. برای جزئیات بیشتر به آن فایل مراجعه کنید.

---

## 1. الگوی Saga - درک عمیق

### چه چیزی پیاده‌سازی شد

- **هماهنگ‌کننده**: Marketplace Service (`OrderSagaService`) به عنوان هماهنگ‌کننده Saga برای checkout عمل می‌کند
- **شرکت‌کنندگان**:
  - Payment Service: مجوز و لغو پرداخت‌ها
  - خود Marketplace: مدیریت چرخه حیات سفارش و موجودی

### گردش کار

```
1. ایجاد سفارش `PENDING` با آیتم‌ها
2. فراخوانی Payment Service برای مجوز پرداخت
3. اگر مجوز داده شد:
   - اعتبارسنجی و کاهش موجودی با قفل بدبینانه
4. اگر هر شکستی رخ داد:
   - علامت‌گذاری سفارش به `CANCELED`
   - جبران با لغو پرداخت در صورت لزوم
5. در صورت موفقیت:
   - علامت‌گذاری سفارش به `CONFIRMED`
   - انتشار `OrderConfirmedEvent` به RabbitMQ
```

### درس‌های آموخته شده

1. **تراکنش‌های محلی + جبران در مقابل تراکنش‌های سراسری**
   - Sagaها تراکنش‌های محلی با اقدامات جبرانی را به جای تراکنش‌های ACID سراسری می‌پذیرند
   - این وابستگی به یک مدیر تراکنش مرکزی را کاهش می‌دهد و با میکروسرویس‌ها سازگارتر است
   - مصالحه: سازگاری در نهایت است و باید در وضعیت‌های دامنه (`PENDING`, `CONFIRMED`, `CANCELED`) قابل مشاهده باشد

2. **وضعیت‌های دامنه صریح وضوح را بهبود می‌دهند**
   - مدل‌سازی صریح `OrderStatus` رفتار سیستم را آسان‌تر برای درک و تست می‌کند
   - قابلیت مشاهده وضعیت‌های سفارش برای اشکال‌زدایی و پشتیبانی کاربر حیاتی است

3. **تست‌ها باید مسیرهای شکست را پوشش دهند**
   - تست‌های مسیر موفق کافی نیستند
   - شکست‌های مجوز پرداخت باید بدون تغییرات موجودی مدیریت شوند
   - شکست‌های موجودی پس از مجوز موفق باید جبران را فعال کنند

4. **ایدمپوتنسی و ایمنی**
   - مراحل Saga و جبران‌ها باید ایدمپوتنت یا امن برای تلاش مجدد باشند
   - الگوهای استفاده شده آماده تقویت با توکن‌های ایدمپوتنت هستند

---

## 2. الگوی Circuit Breaker - درک عمیق

### چه چیزی پیاده‌سازی شد

- **محل قرارگیری**: در Exam Service، پوشاندن فراخوانی‌های HTTP خروجی به Notification Service
- **کتابخانه**: Resilience4j (`resilience4j-spring-boot3`)
- **رفتار**:
  - هنگام شروع آزمون:
    - یک Circuit Breaker (`notificationCb`) فراخوانی به `/notification/notify/exam/{examId}` را احاطه می‌کند
    - در صورت شکست یا مدار باز:
      - یک fallback خطا را لاگ می‌کند
      - آزمون همچنان به `LIVE` منتقل می‌شود
      - یک `ExamStartedEvent` همچنان به RabbitMQ منتشر می‌شود

### درس‌های آموخته شده

1. **وابستگی‌های حیاتی در مقابل غیرحیاتی**
   - شروع آزمون یک عملیات حیاتی است؛ اعلان‌ها مهم اما غیرحیاتی هستند
   - Circuit Breakerها به تمایز این موارد کمک می‌کنند با جلوگیری از آبشاری شکست غیرحیاتی به جریان‌های حیاتی

2. **Fallbackها باید متفکرانه باشند**
   - یک fallback باید:
     - اثرات جانبی مهم را حفظ کند (انتقال وضعیت آزمون)
     - زمینه کافی (examId, tenantId, exception) را برای عیب‌یابی لاگ کند
   - نباید خطاها را بی‌صدا ببلعد؛ قابلیت مشاهده ضروری است

3. **تنظیم پیکربندی**
   - تنظیمات Circuit Breaker (اندازه پنجره، آستانه نرخ شکست، مدت انتظار) مصالحه‌هایی هستند:
     - خیلی تهاجمی → مدارهای باز غیرضروری
     - خیلی ملایم → تخریب طولانی مدت
   - در این پروژه، مقادیر پیش‌فرض استفاده شده، اما معماری امکان تنظیم دقیق بر اساس متریک‌های تولید را می‌دهد

4. **الگوهای مکمل**
   - Circuit Breakerها به خوبی با موارد زیر کار می‌کنند:
     - Retries (برای تلاش‌های مجدد)
     - Timeouts (برای محدود کردن مدت فراخوانی)
     - Bulkheads (برای ایزوله‌سازی منابع)

---

## 3. معماری رویدادمحور (الگوی Observer)

### چه چیزی پیاده‌سازی شد

- **تولیدکنندگان رویداد**:
  - Marketplace Service: انتشار `OrderConfirmedEvent` در تکمیل موفق Saga
  - Exam Service: انتشار `ExamStartedEvent` در شروع آزمون
- **مصرف‌کننده رویداد**:
  - Notification Service با استفاده از RabbitMQ و `@RabbitListener` گوش می‌دهد
  - هر رویداد به عنوان یک `NotificationLog` با payload و tenant id ذخیره می‌شود

### درس‌های آموخته شده

1. **اتصال سست از طریق رویدادها**
   - تولیدکنندگان چیزی از مصرف‌کنندگان نمی‌دانند
   - مصرف‌کنندگان جدید (تحلیل، مانیتورینگ) می‌توانند بدون لمس دامنه‌های اصلی اضافه شوند

2. **قابلیت مشاهده**
   - رویدادها یک ردپای حسابرسی طبیعی از عملیات مهم دامنه تشکیل می‌دهند
   - ذخیره رویدادها در `NotificationLog` یک تاریخچه قابل جستجو برای اشکال‌زدایی و گزارش‌گیری فراهم می‌کند

3. **رویدادهای دامنه‌محور**
   - رویدادها به زبان دامنه بیان می‌شوند (`order.confirmed`, `exam.started`)، نه زبان فنی
   - این معماری را برای توضیح و استدلال با متخصصان دامنه آسان‌تر می‌کند

4. **سازگاری در نهایت**
   - سیستم می‌پذیرد که اعلان‌ها ممکن است از عملیات اصلی عقب بمانند
   - برای تجربه کاربری، این قابل قبول است تا زمانی که اقدامات اصلی سازگار و قابل اعتماد باشند

---

## 4. میکروسرویس‌ها و Bounded Contexts

### چه چیزی اعمال شد

- هر دامنه اصلی سرویس و پایگاه داده خود را دارد:
  - Auth, Booking, Marketplace, Payment, Exam, Notification, Dashboard
- API Gateway متمرکز می‌کند:
  - احراز هویت (اعتبارسنجی JWT)
  - RBAC برای عملیات حساس
  - مسیریابی و تزریق هدر

### درس‌های آموخته شده

- نگه داشتن سرویس‌ها منسجم (Auth vs Booking vs Exam) استدلال درباره invariantها و حالت‌های شکست را ساده می‌کند
- پایگاه‌های داده جداگانه برای هر سرویس از coupling بین سرویسی و درهم‌تنیدگی schema جلوگیری می‌کند
- API Gateway مکان طبیعی برای اجرای نگرانی‌های افقی مانند احراز هویت، RBAC و انتشار هدر چندمستأجاری است

---

## 5. چندمستأجاری و امنیت

### چه چیزی پیاده‌سازی شد

- **چندمستأجاری**:
  - ایزوله‌سازی مستأجر در سطح ردیف در هر سرویس با استفاده از ستون‌های `tenantId`
  - انتشار مستأجر از JWT → Gateway → هدر `X-Tenant-Id` → queryهای سرویس
- **امنیت**:
  - احراز هویت مبتنی بر JWT با نقش‌ها (STUDENT, TEACHER, ADMIN)
  - RBAC در Gateway و درون سرویس‌ها

### درس‌های آموخته شده

1. **زمینه مستأجر به عنوان یک نگرانی درجه یک**
   - عدم گنجاندن فیلترهای مستأجر در queryها ریسک اصلی است
   - صریح کردن tenant id در مدل‌های entity، repositoryها و امضای متدها این ریسک را بسیار کاهش می‌دهد

2. **لایه‌های امنیت**
   - RBAC در سطح Gateway تصمیمات سطح مسیر را ساده می‌کند
   - بررسی‌های سطح سرویس همچنان برای قوانین خاص کسب‌وکار ضروری هستند

3. **ایزوله‌سازی داده در مقابل پیچیدگی عملیاتی**
   - ایزوله‌سازی مستأجر در سطح ردیف به علاوه database-per-service تعادل خوبی برای این پروژه ایجاد می‌کند

---

## 6. الگوی State برای چرخه حیات آزمون

### چه چیزی پیاده‌سازی شد

- **وضعیت‌ها**: DRAFT → SCHEDULED → LIVE → CLOSED
- **کلاس‌ها**: `DraftExamState`, `ScheduledExamState`, `LiveExamState`, `ClosedExamState`
- **Factory**: `ExamStateFactory` برای ایجاد شیء وضعیت مناسب

### درس‌های آموخته شده

1. **جداسازی رفتار از وضعیت**
   - هر کلاس state مسئول رفتار خاص آن وضعیت است
   - انتقال‌های وضعیت فقط در صورت مجاز بودن انجام می‌شوند

2. **قابلیت توسعه**
   - اضافه کردن وضعیت جدید فقط نیاز به یک کلاس جدید دارد
   - رفتار موجود بدون تغییر باقی می‌ماند

---

## 7. الگوی Strategy برای پرداخت

### چه چیزی پیاده‌سازی شد

- **رابط**: `PaymentStrategy`
- **پیاده‌سازی**: `MockPaymentStrategy`
- **استفاده**: Payment Service از strategy برای پردازش پرداخت استفاده می‌کند

### درس‌های آموخته شده

1. **انتزاع ارائه‌دهنده**
   - ارائه‌دهندگان پرداخت مختلف می‌توانند بدون تغییر کد سرویس اضافه شوند
   - انتخاب strategy می‌تواند در زمان اجرا بر اساس تنظیمات باشد

2. **تست‌پذیری**
   - Mock strategyها تست‌ها را قابل پیش‌بینی می‌کنند
   - نیازی به تعامل با ارائه‌دهندگان واقعی در تست‌ها نیست

---

## 8. تست و کیفیت

### چه چیزی اضافه و اصلاح شد

- تست‌های یکپارچه برای:
  - رزرواسیون‌های Booking (اطمینان از `409 Conflict` برای رزرواسیون‌های همپوشان)
  - تلاش‌های رزرو **همزمان** برای نشان دادن جلوگیری از overbooking با قفل بدبینانه
  - Saga checkout بازارچه (موفقیت، شکست پرداخت، کمبود موجودی با جبران)
  - چرخه حیات آزمون: ایجاد و شروع آزمون‌ها، و ارسال‌های دانشجو
- تست‌های واحد/رفتاری برای:
  - الگوی State آزمون (رفتار DRAFT/SCHEDULED/LIVE/CLOSED)
  - فیلتر JWT Gateway:
    - 401 در صورت نبود توکن
    - 403 وقتی `STUDENT` سعی در ایجاد محصول دارد
    - تزریق صحیح هدر برای نقش‌های TEACHER/ADMIN

### درس‌های آموخته شده

- تست‌های متمرکز بر رفتار (مثل تست‌های همزمانی، تست‌های جبران Saga) ارزشمندتر از تست‌های صرفاً ساختاری هستند
- تست edge caseها در مسیرهای شکست برای سیستم‌های توزیع‌شده ضروری است
- حتی در یک سیستم دمو کوچک، استفاده از تست‌های واقع‌گرایانه معماری را معتبرتر می‌کند

---

## 9. مصالحه‌های معماری

### عملکرد

- **تصمیمات طراحی**:
  - Database-per-service با queryهای ساده و قابل ایندکس
  - کش توزیع‌شده Redis برای لیست محصولات Marketplace
  - TTL 10 دقیقه‌ای برای کش محصولات

- **مصالحه‌ها**:
  - سازگاری قوی برای عملیات اصلی گاهی به معنای قفل DB بیشتر است
  - Redis یک جزء زیرساختی اضافه می‌کند اما مقیاس‌پذیری افقی را فعال می‌کند

### قابلیت اطمینان

- **تکنیک‌های استفاده شده**:
  - قفل بدبینانه برای رزرواسیون‌ها و کاهش موجودی
  - Saga با جبران برای گردش‌های بین سرویسی
  - Circuit Breaker برای فراخوانی‌های اعلان
  - وضعیت‌های دامنه واضح

- **مصالحه‌ها**:
  - پیچیدگی اضافی در هماهنگی و مدیریت وضعیت
  - نیاز به لاگ‌گیری و متریک‌های خوب برای اشکال‌زدایی جریان‌های توزیع‌شده

---

## 10. خلاصه الگوهای اعمال شده

| الگو | پیاده‌سازی | سرویس |
|------|-----------|-------|
| **Saga** | OrderSagaService | Marketplace/Payment |
| **Circuit Breaker** | NotificationClient | Exam → Notification |
| **Observer / Event-driven** | RabbitMQ listeners | Notification |
| **State** | ExamState, ExamStateFactory | Exam |
| **Strategy** | PaymentStrategy | Payment |
| **Repository** | JPA Repositories | All services |
| **Factory** | ExamStateFactory | Exam |

---

## 11. نتیجه‌گیری

این پروژه یادگیری‌های کلیدی زیر را فراهم کرد:

1. **میکروسرویس‌ها نیاز به الگوهای خاص دارند**: Saga, Circuit Breaker, و Observer الگوهای ضروری برای سیستم‌های توزیع‌شده هستند

2. **سازگاری در نهایت قابل مدیریت است**: با طراحی صحیح وضعیت‌های دامنه و مکانیزم‌های جبران

3. **امنیت لایه‌ای ضروری است**: JWT + Gateway RBAC + بررسی‌های سرویس

4. **چندمستأجاری یک نگرانی افقی است**: باید در همه لایه‌ها پیاده‌سازی شود

5. **تست‌های مسیر شکست حیاتی هستند**: تست‌های موفق کافی نیستند

این یادگیری‌ها مستقیماً به سیستم‌های میکروسرویس دنیای واقعی قابل انتقال هستند.

---

**برای جزئیات کامل‌تر، به فایل `docs/ai-interaction-report.md` مراجعه کنید.**
